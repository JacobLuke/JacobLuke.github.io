<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jacob's Blograhams</title><link href="http://jabrahams.ca/" rel="alternate"></link><link href="http://jabrahams.ca/feeds/tech.atom.xml" rel="self"></link><id>http://jabrahams.ca/</id><updated>2014-03-17T12:00:00Z</updated><entry><title>Cast operators in C++</title><link href="http://jabrahams.ca/cpp-casts.html" rel="alternate"></link><updated>2014-03-17T12:00:00Z</updated><author><name>Jacob Abrahams</name></author><id>tag:jabrahams.ca,2014-03-17:cpp-casts.html</id><summary type="html">&lt;p&gt;Alright, I'm done bitching about Java. The maelstrom from my last post was exhausting (on both sides of the issue), and I don't have enough energy to deal with that every single week. Plus, I'm basically out of content on Java (more or less). Originally, that meant that I would spend this week on Python. However, I saw that as kicking another anthill altogether, so I'm pushing that one back at least a week.&lt;/p&gt;
&lt;p&gt;Instead, let's talk about C++.&lt;/p&gt;
&lt;p&gt;As you may have noticed, the title of this article is &lt;em&gt;somewhat&lt;/em&gt; narrow in scope. That's mostly because I couldn't compress my C++ critique to a single article, and slightly to abuse the good faith of my current readerbase in a desperate bid to draw out whatever lifespan this blog has to the last possible second. It's also because I work with C++ fairly rarely, so writing these articles requires drawing out stale vitrol from the dank recesses of my mind, which takes time to cultivate into proper rage. Plus, my relationship with C++ is so much less hateful: I have on multiple occasions &lt;em&gt;actively chosen&lt;/em&gt; to use C++ for tasks. So this will be the first of (let's say) 3 articles. (This number will not update with the number of articles I write. It will just become wrong.)&lt;/p&gt;
&lt;h2&gt;Brief History&lt;/h2&gt;
&lt;p&gt;I'm assuming my audience is mostly made up of classmates or colleagues, but it doesn't hurt to go over how C++ came to be. Around the early 70s, Dennis Ritchie was building Unix at Bell Labs, when he decided he needed a language that was more portable, more readable, and less error-prone than assembly code. He built C instead, and the programmers of the 70s took to it like the other young adults of the 70s took to recreational drug use. By the 80s, Bjarne Stroustrup saw the drug addiction-like damage C was doing to people, and decided that the fix of the problem would be to &lt;em&gt;add more features&lt;/em&gt;, which is eerily similar to heroin's early history. He spearheaded efforts to build a new language, which he dubbed, "C with Classes, Exceptions, Metaprogramming, Generics, Algorithms, and everything else I could think of." This was shortened to "C with Classes," which was later shortened to "C++" because languages with long names are rarely successful. [citation needed] &lt;/p&gt;
&lt;p&gt;(Side note: because of post-increment semantics, Bjarne made a language that was the same as what C &lt;em&gt;used&lt;/em&gt; to be, and changed C in the process. The C++-influenced changes in C since the 80s attest to this.)&lt;/p&gt;
&lt;h2&gt;Cast Operators&lt;/h2&gt;
&lt;p&gt;Suppose you have two types, &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt;, and an instance of each, &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; respectively. In C, converting a &lt;code&gt;T&lt;/code&gt; to a &lt;code&gt;V&lt;/code&gt; is easy: just write &lt;code&gt;v = (V)t&lt;/code&gt; and it'll probably do something that makes sense. (To elaborate, it will either make a logical conversion if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are both numerical types, and it will just reinterpret the value at that point in memory without changing it otherwise. Or it will crash in an implementation-defined way if you're being an idiot, and you deserve that.)&lt;/p&gt;
&lt;p&gt;C++ decided that C's handling of the situation was, like the rest of the language, insufficient, and went about fixing it in an extremely questionable way, just like they did with the rest of the language. They noted a few problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Casts are too easy to hide in code. If you're looking for places where &lt;code&gt;T&lt;/code&gt;s are casted to &lt;code&gt;V&lt;/code&gt;s, what string are you going to search the code for? &lt;code&gt;(V)&lt;/code&gt;? Good luck with that.&lt;/li&gt;
&lt;li&gt;Casts don't show any intent. What if you thought that &lt;code&gt;T&lt;/code&gt;s have a logical interpretation as &lt;code&gt;V&lt;/code&gt;s, but in fact your code just ends up manipulating parts of &lt;code&gt;V&lt;/code&gt;s that you really shouldn't be touching? To the C compiler, you could &lt;em&gt;want&lt;/em&gt; to access parts of &lt;code&gt;V&lt;/code&gt; like that, because that's also something C-programmers do, and it has no reason to assume you're a sensible human being.&lt;/li&gt;
&lt;li&gt;Casts aren't user-definable. Well, they kind of are, if you assume that your &lt;code&gt;struct&lt;/code&gt;s are always packed in the same way across different architectures and operating systems. (See above for why the compiler doesn't assume you aren't doing this.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To fix these perceived problems, C++ did a bunch of things. First and foremost, they created four cast operators:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt; - you &lt;em&gt;know&lt;/em&gt; that &lt;code&gt;t&lt;/code&gt; can be thought of as a &lt;code&gt;V&lt;/code&gt;, or you're willing to pay some pretty hefty consequences if you're wrong.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt; - &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are pointer-types, and &lt;code&gt;T&lt;/code&gt; is a base type of &lt;code&gt;V&lt;/code&gt;. You're pretty sure &lt;code&gt;t&lt;/code&gt; is actually a &lt;code&gt;V&lt;/code&gt;, but you don't want your program to explode if you're wrong, so you're okay if an exception (specifically &lt;code&gt;std::bad_cast&lt;/code&gt;) is thrown when your assumption turns out to be false.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt; - you know that &lt;code&gt;t&lt;/code&gt; isn't a &lt;code&gt;V&lt;/code&gt;, but you think that the binary data in a &lt;code&gt;T&lt;/code&gt; makes sense interpreted as a &lt;code&gt;V&lt;/code&gt;, so you want the compiler to just look the other way for a second or two.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt; - You know that &lt;code&gt;T&lt;/code&gt;s say they shouldn't be modified, but you have reason to believe that it's okay to do so (assuming that &lt;code&gt;T&lt;/code&gt; is a &lt;code&gt;const V&lt;/code&gt;). You can also cast away volatility, but I don't really know why you would.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Boost is also trying to add &lt;code&gt;lexical_cast&lt;/code&gt; to the group, which would act like &lt;code&gt;[tT]oString&lt;/code&gt; in Java/C# but in a bidirectional way, which is kind of neat.)&lt;/p&gt;
&lt;p&gt;If you didn't catch my tone, &lt;em&gt;most of these casts are almost always wrong&lt;/em&gt;. Let's go through them again:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; is fine, generally speaking. Nice and greppable, clearly shows intent, and is comparable in speed to a C-cast.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic&lt;/code&gt; shows too much doubt on the part of the programmer: why do you only &lt;em&gt;think&lt;/em&gt; &lt;code&gt;t&lt;/code&gt; is a &lt;code&gt;V&lt;/code&gt;? Where is this object coming from if you can't accurately describe its type &lt;em&gt;but you still need to know what it is&lt;/em&gt;? Most importantly, &lt;em&gt;why are you ever downcasting&lt;/em&gt;? (It's also really slow compared to the others.)&lt;/li&gt;
&lt;li&gt;Do I really need to explain why &lt;code&gt;reinterpret&lt;/code&gt; is bad? If &lt;code&gt;static&lt;/code&gt; won't compile, then you should step back, take a deep breath, and go back to writing assembly. A &lt;code&gt;std::pair&amp;lt;int, int&amp;gt;&lt;/code&gt; is not and will never be a &lt;code&gt;double&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt; is justifiable when you're dealing with stupid APIs that give you &lt;code&gt;const&lt;/code&gt; variables that you know you can actually write to. If you're &lt;code&gt;const_cast&lt;/code&gt;ing in code entirely written by you or someone you know, you should &lt;em&gt;really&lt;/em&gt; reconsider.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For backwards-compatability, C++ includes the C-style cast operator. It's behaviour is basically to run through all these cast operators until one makes sense. This is, of course, almost never what you want, since it solves &lt;em&gt;none&lt;/em&gt; of the problems the operator had in C.&lt;/p&gt;
&lt;p&gt;Oh, and there are two other cast operator-like options provided in C++:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;you can define an &lt;code&gt;operator V&lt;/code&gt; function inside &lt;code&gt;T&lt;/code&gt;'s definition. Or anywhere else, because operators can be overloaded in any scope.&lt;/li&gt;
&lt;li&gt;you can define a constructor in &lt;code&gt;V&lt;/code&gt; that takes a single argument that is implicitly convertible to a &lt;code&gt;T&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, I'm leaving something out here. See, both of these are &lt;em&gt;implicit&lt;/em&gt;, meaning you can just write &lt;code&gt;v = t;&lt;/code&gt; and it will just pick the first thing that works. Sure, you can declare either as &lt;code&gt;explicit&lt;/code&gt;, but only in C++11-onwards: &lt;code&gt;explicit&lt;/code&gt; only worked for single-argument constructors &lt;em&gt;for at least 15 years&lt;/em&gt;. This lead to ridiculous efforts to get around the language's limitation including (but not limited to) the &lt;a href="http://www.artima.com/cppsource/safebool.html"&gt;safe-bool idiom&lt;/a&gt; for pointer-like truth-value detection. (This is one of my favourite instances of an extremely complex solution to a simple problem.) Thankfully, this kind of innovation is no longer necessary, but it's still a "gotcha" to watch for, since so few other languages mark conversions as implicit by default.&lt;/p&gt;
&lt;p&gt;(I'm not even going to &lt;em&gt;begin&lt;/em&gt; on how complicated this gets with templates and determining function prototypes, because this article is long enough and I want to do templates as a separate article.)&lt;/p&gt;
&lt;p&gt;Does C++ handle this all wrong? I'm on the fence with that. Sure, languages like C# have a more structured, logical approach to casts and conversions (eg. limiting the scope, forcing an explicit/implicit declaration etc.), but C++'s design has always been about giving the programmer as many tools as possible without restricting their freedom. Really, it should be common sense not to abuse &lt;code&gt;reinterpret_cast&lt;/code&gt;, but if you're crazy enough to want to, well, C++ will hand you the keyword. It's not going to stop you from pointing the gun at your foot, but it'll help you dial 911. (Unfortunately, it won't stop you from tearing out the phone lines.) The implicit-cast-by-default thing is strange, sure, but once you're aware of it you can probably handle it. All in all, C++ lets you do what you want quickly and (if you choose to) clearly, and that's all that really matters.&lt;/p&gt;
&lt;p&gt;To sum up:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++ adds 4 more cast operators. 3 are usually a sign of bad programming somewhere along the line.&lt;/li&gt;
&lt;li&gt;C++ lets you define conversions, but you might be surprised when it decides to apply them.&lt;/li&gt;
&lt;li&gt;The design of casting in C++ makes sense for C++, as long as you're okay with that&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ is &lt;em&gt;huge&lt;/em&gt;. I just wrote more on one tiny part of it than I wrote on &lt;em&gt;all of Java&lt;/em&gt;. And I'm probably going to write more, given the right feedback. If that sounds like a good thing, let me know. 'Til then, I'll just continue waiting for my Java-based IDE to unfreeze.&lt;/p&gt;
&lt;p&gt;(Seriously. Not even kidding)&lt;/p&gt;
&lt;p&gt;J&lt;/p&gt;</summary><category term="nerdish"></category><category term="programming"></category><category term="c++"></category></entry><entry><title>Java - the Barbed-Wire Fence of Programming</title><link href="http://jabrahams.ca/java.html" rel="alternate"></link><updated>2014-03-08T19:00:00Z</updated><author><name>Jacob Abrahams</name></author><id>tag:jabrahams.ca,2014-03-08:java.html</id><summary type="html">&lt;p&gt;Occasionally, I like to take a step back and look at the programming languages I've used over the years. What better place to start than with my first, my last, my everything?&lt;/p&gt;
&lt;p&gt;I've been programming Java since high school, and it was the first real language I was exposed to. I suspect that, when I sleep, I still type&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;because it's &lt;em&gt;that&lt;/em&gt; ingrained in my muscle memory. And you know what?&lt;/p&gt;
&lt;p&gt;Java is an &lt;em&gt;awful&lt;/em&gt; choice for a first language.&lt;/p&gt;
&lt;p&gt;I'm not going to just state that, I'll give reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java &lt;em&gt;requires&lt;/em&gt; Object-Oriented Programming. Every java program is a function embedded in an object. Way to keep a gentle learning curve, there.&lt;/li&gt;
&lt;li&gt;Java relies extensively on imports from other libraries, and other classes and types. That's so much to explain to a beginning programmer. Or not, which was the case with me: just don't explain anything, and just use it.&lt;/li&gt;
&lt;li&gt;Java forces exception handling. Never mind that you're just starting out and probably don't even know what an exception is.&lt;/li&gt;
&lt;li&gt;Java is garbage-collected, which means that you don't even know where things are going. &lt;code&gt;new&lt;/code&gt; is just a keyword that makes things happen to you.&lt;/li&gt;
&lt;li&gt;Java tends to use verbosity to the extreme: it makes simple tasks tedious, and complex tasks impossible.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Probably think with Point 4 up there that I advocate C or C++ instead, right? Well, yes and no. I think that those languages are great for teaching a fledgling programmer that the program you write can do horrible, terrifying things if you fuck up, which can be great for traumatizing a freshman programmer into getting his/her shit together, or it can mess up their mind really badly. I also think that languages like Python are too high-level to make certain the programmer knows exactly what they're doing, relying on language constructs more than common sense. So, I'd actually like to see someone teach using C and Python &lt;em&gt;in combination&lt;/em&gt;. (Though not in CPython, because that's really just the worst of both worlds.)&lt;/p&gt;
&lt;p&gt;Anyway, this article isn't about ripping on Java as a choice of teaching language. It's about ripping on Java's design choices. Full disclosure from this point on: I actually write Java full-time, so I'm going to avoid writing my way out of a job.&lt;/p&gt;
&lt;p&gt;Let's get down to it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verbosity. Oh my &lt;em&gt;God&lt;/em&gt; the verbosity. My fingers sometimes hurt after typing Java more than they'd hurt after an essay or a particularly long-winded blog post.&lt;/li&gt;
&lt;li&gt;Strictness in file organization. A file named [Foo].java can only have one public class named [Foo]. If it's in a packaged called com.abba.jesus.pidgeot, then it's file path has to be &lt;code&gt;[something]/com/abba/jesus/pidgeot/Foo.java&lt;/code&gt;, even if there's nothing in packages com, com.abba, or com.jesus.&lt;/li&gt;
&lt;li&gt;Weird type-boxing/casting rules. Each of the value types is implicitly convertible to a related class in &lt;code&gt;java.util&lt;/code&gt; (ie. &lt;code&gt;int&lt;/code&gt; =&amp;gt; &lt;code&gt;java.util.Integer&lt;/code&gt;)...except as an argument to a generic class, where it has to be declared as the class rather than the value-type (ie. &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt; is a ParseException). This is fine (mostly), except that any function that takes a generic &lt;code&gt;T[]&lt;/code&gt; has to have a &lt;em&gt;separate implementation for each value type&lt;/em&gt;. Further, Java disallows casts between different class types (that aren't covariant)...except for a variable of &lt;em&gt;any&lt;/em&gt; type &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;v + ""&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; a string and never results in a NullPointerException when &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The weirdness of exception handling. Prior to Java 7, there was no way to handle multiple exceptions in a single block, leaving copious room for typos in copy-pasting the same damn block to both related handlers. Oh, and you have to handle every Exception, regardless of if it makes sense to...unless it's a RuntimeException. Then the JVM gives it a free pass. Why even &lt;em&gt;have&lt;/em&gt; a duality? Why not just have stuff like that be handled as Errors or something?&lt;/li&gt;
&lt;li&gt;Weirdly inconsistent library support. See &lt;a href="http://tech.puredanger.com/2010/03/31/do-we-want-a-java-util-pair/"&gt;this article&lt;/a&gt; on the concept of a Pair class, for instance. They basically say, "Oh I don't think it's necessary, so no one else will." I've also heard people say, "Programmers will use it wrong." That is a &lt;em&gt;terrible&lt;/em&gt; reason not to support something, especially in a util class of all things. On that note...&lt;/li&gt;
&lt;li&gt;Complete lack of operator overloading. Which would you rather see:
    &lt;pre&gt;
    BigInteger a = new BigInteger("12343212");
    BigInteger b = new BigInteger("234231999");
    BigInteger c = new BigInteger("65565790099");
    return c.add(b.muliply(a));
    &lt;/pre&gt;
    or
    &lt;pre&gt;
    return c + (b * a);
    &lt;/pre&gt;
    Again, the response seems to be, "People will use it wrong." And a lot of the time, the hatred is directed at C++, specifically the stream operator:
    &lt;pre&gt;
    int i;
    cin &amp;gt;&amp;gt; i;
    cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;
    &lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To compare, let's discuss Scala, a language built on top of the JVM. Let's see what it does differently:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verbosity. Scala tends towards the succinct whenever possible, at least in my experience.&lt;/li&gt;
&lt;li&gt;More free-form package organization. Scala will find your files, don't worry about what you name them. You can also put more than one top-level public class in a single file (though this is still discouraged)&lt;/li&gt;
&lt;li&gt;More intuitive type-coercion. Scala's type system is complex. I don't know enough about lambda calculus to pretend I fully understand every part of it, but I do know they make value types &lt;em&gt;effectively just a different part of the standard hierarchy&lt;/em&gt;. &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt; isn't a syntax problem anymore: it just works.&lt;/li&gt;
&lt;li&gt;Free-form casting and conversions. Want &lt;code&gt;A&lt;/code&gt; to always make sense as a &lt;code&gt;B&lt;/code&gt;? Why not! You can do that.&lt;/li&gt;
&lt;li&gt;No exceptions are forced to be checked anymore. Rejoice!&lt;/li&gt;
&lt;li&gt;On the library support, it just tries to have as wide support as possible, which isn't always a good thing. (Want to know all of Scala? Too bad, that's what the internet's for.)&lt;/li&gt;
&lt;li&gt;Operator overloading is just another function. This &lt;em&gt;maybe&lt;/em&gt; goes a bit too far, since you can make operators using basically any character. (The &lt;code&gt;/:&lt;/code&gt; operator for fold-left is my favourite.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And, while we're at it, let's look at C#, a language made because Microsoft didn't want to be sued for using Java at one point[citation needed]:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Still verbose, though I'd argue less so.&lt;/li&gt;
&lt;li&gt;Package organization? Totally up to you. Hey, have 5 classes per file if you want.&lt;/li&gt;
&lt;li&gt;A similar (though simpler) type system to Scala. Value types are &lt;code&gt;struct&lt;/code&gt;s, everything else is an &lt;code&gt;obejct&lt;/code&gt;, and &lt;code&gt;struct&lt;/code&gt;s can be semantically treated like &lt;code&gt;object&lt;/code&gt;s.&lt;/li&gt;
&lt;li&gt;Define your own cast operators! Make them as explicit as you want! &lt;/li&gt;
&lt;li&gt;Exceptions don't need to be checked. Funny how often this pops up...&lt;/li&gt;
&lt;li&gt;A decent-ish standard library which supports most of the things you'd want. Maps that &lt;em&gt;actually&lt;/em&gt; act the same as other iterables (as they damn-well should).&lt;/li&gt;
&lt;li&gt;Override &lt;em&gt;only the existing operators and only within the definition  of the class itself&lt;/em&gt; (ie, no overriding &lt;code&gt;int + int&lt;/code&gt; or something). Humourously, the bit shift operators (ie. the straming operators in C++) can only have the second operand be an &lt;code&gt;int&lt;/code&gt;, &lt;em&gt;because they're still pissed about that&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Don't take this to mean Java does everything wrong. The JVM is a great piece of technology, and the language has some neat constructs seen rarely elsewhere. (Anonymous interfaces, anyone?) But &lt;em&gt;so many&lt;/em&gt; of its design decisions serve merely to act out of spite to the admittedly-overindulgent amount of freedom that C++ gives programmers. And spite is a &lt;em&gt;terrible&lt;/em&gt; way to drive a design process. Scala, it seems, was designed out of counter-spite: it is &lt;em&gt;so&lt;/em&gt; different from Java, yet is based on the exact same technology stack. In my mind, &lt;em&gt;Scala is the biggest "Fuck You" to Java that exists&lt;/em&gt;. (C# only loses out on this because it's tied so tightly to Windows that it rarely sees the light of day outside of Microsoft developer pet-projects and ASP.NET-based websites.) And when a competitor springs up just to subvert everything you've done in an ironic way? Face it, Java, you've become the new C++. And not in a good way.&lt;/p&gt;
&lt;p&gt;So there's my Java rant. It's been a long time coming. I'll probably dissect Python at some point, so if that interests you, tune in again.
'Til then, I'll be waiting for my code to compile.&lt;/p&gt;
&lt;p&gt;J&lt;/p&gt;</summary><category term="tech"></category><category term="programming"></category><category term="nerdish"></category></entry><entry><title>Pelican, or, How I came to despise Ruby</title><link href="http://jabrahams.ca/pelican.html" rel="alternate"></link><updated>2014-03-02T09:15:00Z</updated><author><name>Jacob Abrahams</name></author><id>tag:jabrahams.ca,2014-03-02:pelican.html</id><summary type="html">&lt;p&gt;This blog has been in the works for...well...a while now.&lt;/p&gt;
&lt;p&gt;Maybe a year, give or take.&lt;/p&gt;
&lt;p&gt;I bought the domain name back in October in the hopes of having something to show off to interviewers. When it came down to actually making the site, I ran into some issues.&lt;/p&gt;
&lt;p&gt;Namely, I had no idea how to do that.&lt;/p&gt;
&lt;p&gt;To give myself some credit, I did know a thing or two of HTML, CSS, Javascript, jQuery, and nodejs (which is what I was initially using to serve pages, from within a heroku app). But I didn't know good design practices for web (how do i shot CSS), had a lot of out-of-date information (I blame learning HTML back at 1.0), and was too cocky to just delegate all the hard decisions to an existing framework.&lt;/p&gt;
&lt;p&gt;I chose to fix the last one.&lt;/p&gt;
&lt;p&gt;The result was a broken mess that I couldn't bear to link to on my resume out of shame (but will link to &lt;a href="http://jabrahams-1.herokuapp.com"&gt;here&lt;/a&gt; out of shamelessness). So yesterday, I sat down and made some changes, because I felt work-sick and knew the only way to remedy that was to stare at text files for hours on end. I made a &lt;a href="http://github.com/JacobLuke/jacobluke.github.io"&gt;github.io repository&lt;/a&gt; and picked a framework: Octopress. It came well-recommended by various acquaintances, it had a neat aesthetic, and the deploy process looked pretty straightforward.&lt;/p&gt;
&lt;p&gt;That mistake cost me 4 hours.&lt;/p&gt;
&lt;p&gt;Let me elaborate a little. I run Windows, partially because I have been for years, partially because I like being able to game, and mostly because of inertia. (I've run Mint and Ubuntu in the past and will probably reinstall one of them at one point.) Octopress is built in Ruby. If there's one programming language community that utterly despises Windows users, it's...well, it's Objective-C, but Ruby's a close second. Basically every step of the build process had to be finagled into working. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ruby 2.0.0 doesn't work? Ruby 1.9.3 gets you one step further before breaking.&lt;/li&gt;
&lt;li&gt;Ruby just won't build? Need the not-optional-but-also-not-pre-bundled devkit.&lt;/li&gt;
&lt;li&gt;Gems won't install? Oh, by default they're sent as &lt;em&gt;binaries&lt;/em&gt;, which are obviously not going to work on a completely different operating system.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before I even found the answer to that third one, I was already looking for alternatives. Github pages (like this one) ship with Jekyll by default, but that was apparently just a less-well-loved Octopress. Plus it was still in Ruby. I considered not using a publishing platform, just injecting Bootstrap into the page to make it a little prettier, but decided that I'd rather do something a little more. I even considered writing my own publishing platform, but realized that was way beyond my effort-threshold for this blog. And then I found Pelican.&lt;/p&gt;
&lt;p&gt;Pelican is a blogging framework written in Python. This had a ton of advantages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I know that Python at least runs on Windows, since it's what I do most of my non-work day-to-day coding in&lt;/li&gt;
&lt;li&gt;Python projects typically have at least half-decent support for people chained to Microsoft. I actually find it's often better than their Mac support.&lt;/li&gt;
&lt;li&gt;I know enough of the language to debug things when stuff goes wrong, or potentially extend/contribute the project in some way.&lt;/li&gt;
&lt;li&gt;Usually the python community is nice people. Usually.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So I uninstalled Ruby (both versions that had made their way to my machine), deleted all the random repositories I'd checked out trying to make it work, reset all the settings that the installers had broken, and checked out Pelican. Or tried to, realized that my &lt;code&gt;PATH&lt;/code&gt; environment variable was missing most of the subdirectories of my Python installation, fixed that, and got everything working-enough to actually publish an article. And, after some early-morning wrangling with my Host configurations, this blog was born.&lt;/p&gt;
&lt;p&gt;To sum up:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Don't use Windows&lt;/li&gt;
&lt;li&gt;If you absolutely must use Windows, don't use Ruby. Use Python.&lt;/li&gt;
&lt;li&gt;When in doubt, add more stuff to &lt;code&gt;PATH&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now excuse me while I hunt down a configuration setting.&lt;/p&gt;
&lt;p&gt;J&lt;/p&gt;</summary><category term="tech"></category><category term="nerdish stuff"></category><category term="programming"></category><category term="metablogging"></category></entry></feed>